<html>
<body>
<h1>Sistemas distribuídos: Conceito, desafios e exemplos</h1>

Um sistema distribuído é aquele que seus componentes utilizam recursos separados e unem suas funcionalidades para atingir uma finalidade em comum. Na informática, a separação de componentes (implicando o processamento e memórias) trazem mais necessidade de infraestrutura e complexidade a um projeto mas garantem eficiência, escalabilidade, confiabilidade e velocidade de resposta, com a possível redução de custos do sistema a longo prazo; por isso, são comuns em sistemas que exigem evitar falhas centrais e gargalos de disponibilidade.

Sistemas distribuídos são implementados em diversos locais, como em redes de telefonia, caixas eletrônicos para transações financeiras e Internet das Coisas. Um exemplo mais óbvio é o meio em que você acessou este artigo; as informações e recursos computacionais da internet (World Wide Web) residem em diversas máquinas ao redor do mundo.

É importante entender que este é apenas um conceito; não há uma linguagem ou padrão único a seguir quando se trata de distribuir um sistema. Mas os obstáculos na implementação são geralmente os mesmos, como a manutenção e complexidade do sistema aumentam conforme estes tornam-se mais distribuídos.

<h2>Desafios de sistemas distribuídos</h2>
<h3>Troca de mensagens</h3>
Em um sistema tradicional que opera somente na máquina do usuário, quaisquer erros são contidos dentro da instância do programa, não precisando enviar dados em alguma rede. Mas em um mesmo sistema onde cada dado necessário para uma operação é mantido em servidores separados, é necessária a troca de mensagens para todos estes servidores. Se dois componentes não conseguem trocar mensagens por algum motivo, esta comunicação deve se resolver o mais rápido possível ou ser atendida por outros servidores para que o usuário receba as informações que deseja em um tempo desejável.

<h3>Testes</h3>
Os testes de software de um sistema distribuído devem levar em conta como cada componente pode falhar, sejam de forma independentes ou em conjunto. O resultado das operações do sistema podem se tornar mais imprevisíveis por isso.

<h3>Segurança</h3>
Apenas os componentes que se integram ao sistema ou aqueles autorizados pelo desenvolvedor devem conversar e mandar informações sensíveis pela rede. A segurança de dados físicos também deve levar em conta cada componente que as possui.

<h1>gRPC</h1>
https://www.zup.com.br/blog/grpc-o-que-e-beagle
O gRPC é uma estrutura de programação distribuída RPC (chamadas remotas) para comunicação entre microsserviços, com a proposta de que o cliente interaja com o servidor por chamadas de funções simples, geradas automaticamente pela própria aplicação; assim, é apenas necessário implementar sua lógica de programação, facilitando a adoção desse recurso. Ele pode conectar serviços dentro e entre data centers com suporte para balanceamento de carga, rastreamento, verificação de integridade e autenticação. Também é aplicável na última milha de computação distribuída para conectar dispositivos, aplicativos móveis e navegadores a serviços de back-end. Algumas vantagens do gRPC para a arquitetura de microsserviços são o fácil contato entre clientes e servidores, melhor desempenho dos serviços e features nativas do HTTP/2, como streaming de dados, monitoramento entre outros.

<h2>Alternativas do gRPC</h2>
<h3>REST</h3>
O Representational State Transfer (REST) é o estilo de arquitetura de software mais comum em web services, que define um conjunto de restrições a serem usadas para a criação de web services. O que mais diverge o gRPC do REST é que, com gRPC, são usados caminhos estáticos para um melhor desempenho durante o despacho de chamadas, já que a análise de path params, query params e payload adicionam latência e complexidade à comunicação entre serviços. Também há um conjunto de erros que são mais diretamente aplicáveis ​​a APIs do que os convencionalmente utilizados no REST.
<h3>SOAP
O SOAP (Simple Object Access Protocol) é o sistema mais velho de acesso a dados por XML e HTTP, da época que a internet era mais concentrada em universidades, mas algumas de suas desvantagens de que dados por XML são mais verbosos de serem criados e a falta de suporte a linguagens modernas.

<h1>Apache Kafka</h1>

Os message brokers são uma tecnologia de comunicação entre aplicativos para suportar arquiteturas de cloud híbrida, sem servidor e com base em microsserviços. O Apache Kafka é um dos mais conhecidos, possuindo uma grande comunidade e disponível como open source.
O streaming de eventos é a prática de capturar dados em tempo real de fontes de eventos como bancos de dados, sensores, dispositivos móveis, serviços em nuvem e aplicativos de software na forma de fluxos de eventos; armazenar esses fluxos de eventos de forma durável para recuperação posterior; manipular, processar e reagir aos fluxos de eventos em tempo real e retrospectivamente; e roteando os fluxos de eventos para diferentes tecnologias de destino, conforme necessário. Como uma plataforma de streaming de eventos, o Kafka permite implementar casos de uso para streaming de eventos de ponta a ponta com uma única solução para publicar, armazenar e processar o fluxo de eventos de um sistema.

<h2>Alternativas do Kafka</h2>
<h3>Amazon Kinesis</h3>
O Amazon Kinesis transmite, coleta, processa e analisa fluxos de vídeo e dados em tempo real. Ele fornece informações oportunas e permite total flexibilidade e escalabilidade. Com o Kinesis, você pode ingerir vários tipos de dados, incluindo áudio, vídeo e logs de aplicativos. Possui tiers diferentes de planos pagos para atender os seus usuários. 
<h3>RabbitMQ</h3>
O RabbitMQ é um agente de mensagens de código aberto que pode ser facilmente implantado na nuvem. Além de oferecer suporte a serviços de mensagens assíncronas, oferece uma boa experiência de desenvolvedor com Java, Go, Python, Ruby etc. Como os desenvolvedores usam amplamente o Kafka com vários idiomas, ele é executado em diferentes sistemas operacionais e infraestrutura em nuvem. O RabbitMQ também pode ser implementado em um ambiente distribuído para alta disponibilidade.

https://dev.to/andreidascalu/soap-vs-rest-vs-grpc-vs-graphql-1ib6
https://kafka.apache.org/documentation/
https://hevodata.com/learn/kafka-alternatives/
</body>
</html>